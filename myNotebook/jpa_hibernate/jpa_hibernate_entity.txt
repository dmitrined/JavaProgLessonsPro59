1. Entity в JPA / Hibernate

1.1 Что такое Entity (Сущность)
Entity — это обычный Java-класс (POJO), который связан с таблицей в базе данных.
В терминах JPA, Entity — это не просто объект с данными, а объект,
управление которым берет на себя JPA-провайдер (Hibernate).

Основные правила для создания Entity:
1. Класс должен быть помечен аннотацией @Entity.
2. Должен иметь пустой конструктор (public или protected) —
он нужен Hibernate для создания объектов при извлечении из БД.
3. Должен иметь первичный ключ (@Id) для идентификации записи.
4. Поля класса маппятся (связываются) на колонки таблицы.

Зачем это нужно?
Благодаря Entity мы работаем с базой данных на языке Java:
- Вместо написания SQL-запроса `INSERT INTO cars...` мы создаем объект `new Car()` и сохраняем его.
- Вместо ручного разбора строк таблицы (ResultSet) мы получаем готовые списки объектов `List<Car>`.
- Hibernate сам следит за тем, какие поля объекта изменились, и обновляет базу данных автоматически (Dirty Checking).

Ключевая идея: Entity — это объект, участвующий в управляемом жизненном цикле JPA.
 Hibernate управляет состоянием объекта,а не просто перекладывает данные.

1.2 ORM и роль Hibernate
- JPA (Java Persistence API) — спецификация (контракт): аннотации, интерфейсы, описание сущностей.
- Hibernate — реализация JPA: SQL-генерация, кэширование, lazy-loading, dirty checking.
- Spring Data JPA — слой поверх JPA/Hibernate: автоматические репозитории,
 интеграция с транзакциями, минимум шаблона.

1.3 Persistence Context
Persistence Context — внутренний контейнер Hibernate, который хранит managed entities,
 отслеживает изменения полей и генерирует SQL при flush() или commit.
«Persistence Context = умная карта объектов, связанных с БД»

Следствия:
- Hibernate обновляет Entity без save() внутри транзакции (@Transactional).
- equals / hashCode критичны.
- Lazy-loading работает только при активном контексте.

1.5 Минимальный набор аннотаций Entity
@Entity — объявляет класс сущностью (нужен No-args конструктор).
@Table — задаёт имя таблицы (опционально).
@Id — первичный ключ.
@GeneratedValue — стратегия генерации ID:
- IDENTITY: автоинкремент на стороне БД (самый частый вариант).
- SEQUENCE: использование БД-сиквенсов.
- AUTO: на усмотрение провайдера (Hibernate).

@Column — настройки колонки:
- nullable=false (обязательное поле).
- length=100 (ограничение длины строки).
- unique=true (уникальное значение).
- name (имя колонки в БД).

1.6 Выбор идентификатора (ID)
- Long id (IDENTITY) — простота, масштабируемость.
- UUID — распределённые системы, генерация на стороне приложения.

1.7 Валидация: Java vs БД
1) Bean Validation (Java): @NotBlank, @Size — для пользователя/контроллера.
2) Ограничения БД: nullable = false, unique, FK — последняя линия обороны.

1.8 Связи между Entity
@ManyToOne, @OneToMany, @OneToOne, @ManyToMany.
LAZY (по требованию) vs EAGER (сразу).
Практика: почти всегда LAZY.
