1. Entity в JPA / Hibernate

1.1 Что такое Entity в терминах JPA
Entity — это Java-класс, экземпляры которого JPA-провайдер (чаще всего Hibernate) умеет:
- сохранять в таблицу базы данных,
- извлекать из таблицы,
- обновлять и удалять,
- отслеживать изменения состояния объекта (dirty checking).

Ключевая идея:
- Entity — это не просто POJO с полями.
- Entity — это объект, участвующий в управляемом жизненном цикле JPA.
- Hibernate не просто маппит поля в колонки — он управляет состоянием объекта.

1.2 ORM и роль Hibernate
JPA (Java Persistence API) — это спецификация, контракт:
- какие аннотации существуют,
- какие интерфейсы должны быть,
- как описываются сущности и связи.

Hibernate — наиболее популярная реализация JPA:
- конкретный код,
- SQL-генерация,
- кэширование,
- lazy-loading,
- dirty checking.

Spring Data JPA:
- удобный слой поверх JPA/Hibernate,
- автоматическая реализация репозиториев,
- интеграция с транзакциями Spring,
- минимум шаблонного кода.

1.3 Persistence Context — основа понимания JPA
Persistence Context (контекст персистентности) — это внутренний контейнер Hibernate, который:
- хранит managed entities (управляемые сущности),
- знает, какие объекты соответствуют каким строкам БД,
- отслеживает изменения полей,
- при flush() или commit сам генерирует SQL.

Проще: Persistence Context = «умная карта объектов, связанных с БД»

Важные следствия:
1) Hibernate обновляет Entity без save()
@Transactional
void updateUser() {
    User u = userRepository.findById(1L).get();
    u.setName("Alex");
    // save() не нужен. При commit Hibernate сам сделает UPDATE.
}

2) equals / hashCode критичны: Hibernate сравнивает объекты, а не строки таблицы.
3) Lazy-loading работает только при активном контексте. После закрытия транзакции возникнет LazyInitializationException.

1.5 Минимальный набор аннотаций Entity
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String name;
}

Основные аннотации:
@Entity — объявляет класс сущностью. Обязательно наличие публичного или protected конструктора без аргументов.
@Table — задаёт имя таблицы (опционально).
@Id — первичный ключ.
@GeneratedValue — стратегия генерации ID:
 - IDENTITY: автоинкремент в БД.
 - SEQUENCE: использование последовательностей (sequence).
 - AUTO: выбор провайдера.
@Column — настройки колонки:
 - nullable
 - length
 - unique
 - name
 - insertable = false
 - updatable = false

1.6 Выбор идентификатора (ID)
Самый распространённый вариант:
@Id @GeneratedValue private Long id;
Плюсы: простота, хорош для обучения, хорошо масштабируется.

UUID: 
@Id
@GeneratedValue
private UUID id;
Используется, если: распределённые системы, генерация ID на стороне приложения, нет доверия к автоинкременту.

1.7 Валидация: Java vs БД
1) Bean Validation (Java-уровень)
@NotBlank
@Size(max = 100)
private String email;
Работает: при @Valid в контроллере или при save() (если включён валидатор). Для пользователя.

2) Ограничения БД
- nullable = false
- unique
- индексы
- foreign keys
Последняя линия обороны.

Важно донести:
- Java-валидация — для пользователя.
- БД-ограничения — последняя линия обороны.

1.8 Связи между Entity (обзор)
@ManyToOne — самая частая
@OneToMany
@OneToOne
@ManyToMany — осторожно, часто лучше отдельная сущность

LAZY vs EAGER
LAZY — загрузка по требованию
EAGER — загрузка сразу
Практика: почти всегда LAZY. EAGER в REST часто приводит к большим JSON, циклам и проблемам производительности.