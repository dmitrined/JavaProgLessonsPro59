Spring Boot: Загрузка файлов (File Upload)
1) Как вообще “летит” файл по HTTP
1.1 Почему файл обычно не отправляют как JSON
Файл — это байты (binary data). JSON — текстовый формат.
Теоретически можно кодировать файл в Base64 и отправлять в JSON, но это:

увеличивает размер (Base64 “раздувает” данные),
медленнее,
неудобнее и “не по стандарту”.
1.2 Стандартный способ — multipart/form-data
Загрузка файлов почти всегда делается запросом вида:

Content-Type: multipart/form-data
Смысл: тело HTTP-запроса делится на части (parts):

одна часть может быть файлом (file)
другие части могут быть обычными параметрами (docType, clientEmail и т.д.)
2) Что такое MultipartFile в Spring Boot
Когда клиент отправляет multipart/form-data, Spring может автоматически “распарсить” это и дать вам объект:

MultipartFile
Он содержит:

getOriginalFilename() — имя файла, которое прислал пользователь
getContentType() — тип файла (например image/png, application/pdf)
getSize() — размер файла в байтах
getInputStream() — поток байтов (хорошо для больших файлов)
getBytes() — получить все байты в память (осторожно для больших файлов)
Важно: MultipartFile — это не “файл на диске”.
Это объект, который представляет переданные данные в текущем запросе.

3) Как выглядит endpoint загрузки файла (общая идея)
Обычно upload endpoint — это POST, который принимает multipart/form-data.

Примеры аннотаций:

@PostMapping(consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
@RequestPart("file") MultipartFile file — достать файл из части multipart
@RequestParam String docType — достать обычное поле (query parameter или form field)

Пример контроллера:
```java
@PostMapping(value = "/{carId}/documents", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
public CarDocumentOs uploadDocument(@PathVariable Long carId,
                                    @RequestParam CarDocumentType docType,
                                    @RequestPart("file") MultipartFile file) {
    return carDocumentsOsService.uploadCarDocument(carId, docType, file);
}
```

4) Как тестировать загрузку файла в Postman
4.1 Отправка файла
Method: POST
Body → form-data
Добавить поле:
key: file
type: File
value: выбрать файл
Если нужны доп. поля — добавляем еще form-data keys:
docType
clientEmail
carId
4.2 Типичные ошибки в Postman
вы отправляете JSON вместо form-data
ключ части называется не file, а в контроллере ожидается file
неправильный endpoint / consumes не multipart/form-data
5) Где хранить загруженные файлы: два подхода
Подход A: хранить файл в ОС (File System)
Суть:

сам файл сохраняется в папку на диске (./uploads/...)
в базе данных сохраняются метаданные:
id
originalFilename
storedFilename
contentType
size
path
связи (например carId)
Плюсы:

хорошо подходит для больших файлов
база данных не раздувается
часто быстрее отдавать файл обратно клиенту
Минусы:

нужно бэкапить и БД, и папку
надо следить за правами доступа и путями
при Docker нужно продумать volume (иначе файлы исчезнут при пересоздании контейнера)
Типичные примеры:

фото машины
PDF договоры на машину
техпаспорт автомобиля
Подход B: хранить файл в базе данных (BLOB / @Lob)
Суть:

файл хранится прямо в таблице как byte[]
рядом метаданные (имя, тип, размер, кто загрузил и т.д.)
Плюсы:

всё в одном месте: бэкап БД = данные + файлы
удобнее контролировать доступ (один слой доступа — БД)
Минусы:

база быстро растёт
дампы и миграции становятся тяжёлыми
большие файлы ухудшают производительность базы
Типичные примеры:

небольшие документы клиента (паспорт, водительское, согласия)
6) Важные правила безопасности (обязательно!)
6.1 Не доверяйте имени файла
Пользователь может прислать “опасное” имя:

../../etc/passwd
..\..\windows\system32
Если вы “склеите” путь как строку — можно случайно записать файл не туда.

Правильный подход:

генерировать имя хранения самим (например UUID)
строить пути через Path.resolve(...)

Пример генерации имени:
```java
String originalFilename = file.getOriginalFilename();
String storedFilename = UUID.randomUUID() + "_" + originalFilename.toLowerCase();
Path targetPath = carDir.resolve(storedFilename);
Files.copy(file.getInputStream(), targetPath, StandardCopyOption.REPLACE_EXISTING);
```

6.2 Ограничьте размер файла
Если не ограничить — можно отправить гигабайты и “положить” сервер.

Настройки в application.properties:

spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB
6.3 Проверяйте тип файла (white-list)
Если вы принимаете только PDF и картинки — делайте белый список:

application/pdf
image/jpeg
image/png
Это защищает от загрузки непредусмотренных типов.

Пример проверки:
```java
String contentType = file.getContentType();
boolean allowed = contentType.equals("application/pdf") ||
                  contentType.equals("image/jpeg") ||
                  contentType.equals("image/png");
if(!allowed) {
    throw new IllegalArgumentException("File content type is not allowed " + contentType);
}
```

7) Что сохранять вместе с файлом (минимальный набор метаданных)
При любом способе хранения полезно хранить:

originalFilename — имя для пользователя
contentType — чтобы правильно отдавать при скачивании
size — размер
uploadedAt (опционально) — когда загрузили
owner / carId / clientEmail — привязка к бизнес-объекту
Почему это важно:
иначе у вас будут “файлы без смысла”: непонятно, чей они и что это.

8) Как отдавать файл обратно клиенту (download)
8.1 Если файл хранится в ОС
Вы:

находите путь к файлу
читаете его как ресурс
возвращаете Content-Disposition: attachment

Пример:
```java
public ResponseEntity<Resource> downloadFile(Path path) {
    Resource resource = new UrlResource(path.toUri());
    return ResponseEntity.ok()
            .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + resource.getFilename() + "\"")
            .body(resource);
}
```

8.2 Если файл хранится в БД
Вы:

находите запись в таблице
берёте byte[] data
возвращаете ResponseEntity<byte[]> с правильным Content-Type
9) Когда какой подход выбирать (простая формула)
Большие файлы / много файлов / фото / pdf на авто → хранить в ОС (или объектном хранилище вроде S3)
Небольшие документы, важные для контроля и бэкапа вместе с данными → можно хранить в БД
